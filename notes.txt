todo
- need to build grpah with the pools from pool-sync
- need to be able to update the reserves on each block



- load in all the pools
- generate all teh paths
- on new block get touched reserves
- simulate all paths that use those puts
- put 0.1 eth in to see if profitable then optimzei



weth 3 hop arb cycles



// stream in new block

// simulating price
  sqrtPriceLimitX96=(
                  TickMath.MIN_SQRT_RATIO + 1
                  if zeroForOne
                  else TickMath.MAX_SQRT_RATIO - 1
),


0xca7c2771d248dcbe09eabe0ce57a62e18da178c0 (3301575257374022376880, 57425551100269474282) 1753474795668657 ->
0x4e5cbb6e2aca942252e8cda2ba911ced2bd99b07 (228668635546114631502824, 67254976877966778) 5626302302226136185477 ->
0x10ef7f8833ea986109abc6ef2ac379bf4baf2801 (463177936799461946292349, 7551738123798482608) 100000240908104263 ->

add blaklisted tokens
 BLACKLISTED_TOKENS = [
  #    "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA",  # USDbC
  #    "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",  # USDC
  #    "0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2",  # USDT
  #    "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",  # DAI
  ]

- figure out why you need mint and burn evernts
- pancake swap, sushiswap, swapbased, uniswap

TICKSPACING_BY_FEE: Dict = {
    100: 1,
    500: 10,
    2500: 50,  # Pancake V3
    3000: 60,
    10000: 200,
}
- checkout v3 pool state

GAS_PRICE_ORACLE_ADDRESS = to_checksum_address(
    "0x420000000000000000000000000000000000000F"
)

- need base fee adn base fee next




//let contract = UniswapV2Router::new(
    //address!("7a250d5630B4cF539739dF2C5dAcb4c659F2488D"),
    //anvil_provider.clone(),
//);
     /* 
        for path in profitable_paths {
            let call_path = path.2.clone();
            let UniswapV2Router::getAmountsOutReturn { amounts } = contract
                .getAmountsOut(U256::from(1e17), call_path)
                .call()
                .await
                .unwrap();
            println!(
                "Router amounts: {:?}, Calculated amounts: {:?}",
                amounts.last(),
                path.1
            );
            */
            /*

            let token_path = path.2.clone();
            let amount_in = U256::from(1e17 as u64);
            let arb_path = ArbPath { path:token_path, amount_in , expected_out: path.1.clone() };
            tx_sender.send(arb_path);
            */

            pub fn build_graph(
    pools: &Vec<Pool>,
    top_volume_tokens: HashSet<Address>,
    address_to_node: &mut FxHashMap<Address, NodeIndex>,
    address_to_pool: &mut ConcurrentPool,
    token_to_edge: &mut FxHashMap<(NodeIndex, NodeIndex), EdgeIndex>,
) -> Graph<Address, Address, Undirected> {
    // pools contains all of the pools on the entire blockchain,
    // we are just interested inones with trading volume
    // take the insersection fo the pools and the tokens with top volume
    let top_volume_pools: Vec<Pool> = pools
        .clone()
        .into_iter()
        .filter(|pool| {
            top_volume_tokens.contains(&pool.token0_address())
                && top_volume_tokens.contains(&pool.token1_address())
        })
        .collect();

    // graph
    let mut graph: Graph<Address, Address, Undirected> = Graph::new_undirected();

    for pool in &top_volume_pools {
        let addr0 = pool.token0_address();
        let addr1 = pool.token1_address();
        let node0 = *address_to_node
            .entry(addr0)
            .or_insert_with(|| graph.add_node(addr0));
        let node1 = *address_to_node
            .entry(addr1)
            .or_insert_with(|| graph.add_node(addr1));
        let edge_index = graph.add_edge(node0, node1, pool.address());
        token_to_edge.insert((node0, node1), edge_index);
        token_to_edge.insert((node1, node0), edge_index);
        address_to_pool.track_pool(pool.address(), pool.clone());
    }
    graph
}

pub fn construct_cycles(
    graph: &Graph<Address, Address, Undirected>,
    node: NodeIndex,
) -> Vec<Vec<NodeIndex>> {
    algo::all_simple_paths(&graph, node, node, 0, Some(3)).collect()
}

// Pair contract to get reserves
sol!(
    #[derive(Debug)]
    #[sol(rpc)]
    contract UniswapV2Pair {
        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestamp);
    }
);


    // all our mappings
    //let mut address_to_pool = ConcurrentPool::new(); // for pool data
    //let mut address_to_node: FxHashMap<Address, NodeIndex> = FxHashMap::default(); // for finding node idx
    //let mut token_to_edge: FxHashMap<(NodeIndex, NodeIndex), EdgeIndex> = FxHashMap::default();